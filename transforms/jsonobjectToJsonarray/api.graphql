# Some systems like Firebase and Mavenlink return a set of records not as an array but as a JSON object
# Each record is keyed off something unique (an internal "id" for example)
# and the data for that record is the value of that key
# however, this does not work for GraphQL, because each record cannot become its own type
# We show you how to convert this into an array, so that subsequent processing can be done
# In the first query, we transform the object at the root but return a JSON
# In the second query, we further transform the object to set the right fields
type Customer {
    id: ID
    fullName: String
    age: Int
}

type Query {
    # this query converts a structure {key1:value1,key2:value2,...}
    # to [{"name":key1, "value": value1},{"name":key2, "value": value2},...]
    customerAsNameValue: JSON
    @rest (
        # we are not calling a real endpoint, we will use ecmascript to create data right here
        endpoint: "stepzen:empty" 
        # return the right JSON
        ecmascript: """
        function transformREST(s) {
            return(JSON.stringify({"1":{"fullName":"John Doe", "age":23}, "2":{"fullName":"Jane Smith", age: 25}}))
        }
        """
        # and then transform it using objectToArray
        # here the pathpattern contains only one entry, which means it is applied at the root
        # the pathpattern "<>*" means that at this place, one would find a sequence of zero or more object keys
        transforms: [{pathpattern: ["<>*"], editor: "objectToArray"}]
    )

    # this query first converts a structure {key1:value1,key2:value2,...}
    # to [{"name":key1, "value": value1},{"name":key2, "value": value2},...]
    # then it applies a second transformation to set the right fields of the return type
    # in this case, the second transformation can also be done as setters
    # but we have it commented out
    customerAsCustomer: JSON
    @rest (
        # we are not calling a real endpoint, we will use ecmascript to create data right here
        endpoint: "stepzen:empty" 
        # return the right JSON
        ecmascript: """
        function transformREST(s) {
            return(JSON.stringify({"1":{"fullName":"John Doe", "age":23}, "2":{"fullName":"Jane Smith", age: 25}}))
        }
        """
        # and then transform it using objectToArray
        # here the pathpattern contains only one entry, which means it is applied at the root
        # the pathpattern "<>*" means that at this place, one would find a sequence of zero or more object keys
        # and then do another transformation to convert the name, value pair to the right structure.
        # for the second transformation, it also contains only one entry, which means it is applied at the root
        # the pathpattern "[]*" means at this place, one would find a sequence of zero or more objects
        # jq expression says to treat that zero or more objects as an array and transform each element of the array
        # StepZen takes care of calling jq for each element
        transforms: [{pathpattern: ["<>*"], editor: "objectToArray"}
                    # you could comment this out if you want to try setters instead
                    {pathpattern:["[]*"], editor:"jq:.[]|{id:.name,fullName:.value.name,age:.value.age}"}
                    ]
        # for the second transformation, you can use setters. Uncomment the next line and comment the second pathpattern line above
        # setters: [{field: "id", path: "name"}, {field:"fullName", path: "value.age"}, {field:"age", path:"value.fullName"}]
   )
}