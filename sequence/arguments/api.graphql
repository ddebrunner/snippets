# When a query is called, either in a sequence step, or in an @materializer, how does it get the values of its arguments?

# In a sequence, the first query has access to all the arguments of the enclosing query
# Subsequent queries in the sequence have access to the output of the previous step
# and if it needs an argument from the enclosing query, then it needs to explicitly ask for it, using
# arguments.

# In an @materializer, the query/mutation gets the values of its arguments from the enclosing type
# It defaults to the name of the field matching the name of the argument
# You can override it by explicitly using arguments

# We provide both examples below

type Weather {
    temp: Float
}
type Coord {
    lat: String
    lon: String
}
type Customer {
    name: String
    city: String
}
type Query {
    # An ecmascript return of weather by lat/lon and units (imperial or metric)
    # of course, in real life you will call a weather api
    weather (lat: String, lon: String, units: String): Weather
        @rest (endpoint: "stepzen:empty"
            ecmascript: """
            function transformREST(s) {
                var lat = get('lat')
                var lon = get('lon')
                var units = get('units')
                var temp
                if (lat==25.76 && lon==-80.19)
                    temp = 100.0
                else
                    temp = 60.4
                if (units=='metric')
                    temp = (temp-32)*5/9
                return (JSON.stringify({temp:temp}))
            }
            """
        )
    # An ecmascript converter from cityOrLocale to its lat/lon
    # Of course in real-life you will either call and API, or make a database call
    convertCityOrLocaleToLatLon (cityOrLocale: String):Coord
    @rest (endpoint: "stepzen:empty"
            ecmascript: """
            function transformREST(s) {
                var city = get('city')
                if (city == 'Miami')
                    return (JSON.stringify({lat:25.76,lon:-80.19}))
                else
                    return (JSON.stringify({lat:37.2,lon:-121.19}))
            }
            """
        )
    # A sequence call that sequences converCityOrLocaleToLatLong and weather
    # this allows for a cityOrLocale argument to be used to fetch weather data by lat/lon
    # we have to use an arguments setting for the second query, because   
    # query arguments only flow to the first query in the sequence
    # but we need units to flow to the second query
    # we are saying that the argument named units in the query weather 
    # gets its value from the argument units in the enclosing query
    # In addition to the arguments explictly passed down to the second query,
    # it also gets the output of the first query
    # in this case, the first query returns a type Coord, and therefore its fields lat and lon are
    # available to the second query.
    
    weatherByCityOrLocale (cityOrLocale: String, units: String): Weather
        @sequence(steps:[{query: "convertCityOrLocaleToLatLon"}, 
            {query: "weather", arguments: [{name: "units", argument: "units"}]}])
    # An ecmascript generator of customer data
    # Of course, in real life you will call an API or a database
    customer (id: ID): Customer
    @rest (endpoint: "stepzen:empty"
            ecmascript: """
            function transformREST(s) {
                var id = get('id')
                if (id==1)
                    return (JSON.stringify({name:'John Doe',city:'Miami'}))
                else
                    return (JSON.stringify({name:'Jane Smith',city:'Santa Clara'}))
            }
            """
    )
}

# As a final step, use @materializer to connect customer graph with weather graph
# However, we need another arguments here for two reasons
# One, the Customer type has city
# whereas the query weatherByCityOrLocale expects cityOrLocale
# so we are saying that the argument cityOrLocale in the query weatherByCityOrLocale
# gets its value from the field city in the enclosing type Customer
# Second, because units is not a field in the enclosing type, it needs to be explicitly added

extend type Customer {
    weather (units: String): Weather
    @materializer (query: "weatherByCityOrLocale", arguments: [
        {name: "cityOrLocale", field: "city"}
        {name: "units", argument: "units"}])
}
